<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Andi – Planned Story Graph</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, sans-serif;
      background: #111;
      color: #eee;
      overflow: hidden;
    }

    #container {
      display: grid;
      grid-template-columns: 3fr 1fr;
      height: 100%;
    }

    #graph {
      background: #151515;
    }

    #sidebar {
      border-left: 1px solid #333;
      padding: 12px;
      box-sizing: border-box;
      background: #181818;
      overflow-y: auto;
    }

    #sidebar h1 { font-size: 18px; margin-top: 0; }
    #sidebar h2 { font-size: 16px; margin: 10px 0 4px; }

    #sidebar p { font-size: 14px; margin: 4px 0; }
    #sidebar code { background: #222; padding: 2px 4px; border-radius: 3px; }

    .legend { margin-top: 16px; }
    .legend-item { display: flex; align-items: center; margin: 4px 0; font-size: 13px; }
    .legend-color { width: 16px; height: 16px; border-radius: 50%; margin-right: 8px; }

    .node circle {
      stroke: #111;
      stroke-width: 1.5px;
      cursor: pointer;
    }

    .node text {
      pointer-events: none;
      font-size: 10px;
      fill: #f5f5f5;
      text-shadow: 0 0 3px #000;
    }

    .link {
      fill: none;
      stroke: #666;
      stroke-width: 1.4px;
    }

    .link.highlight {
      stroke: #ffdd57;
      stroke-width: 2.4px;
    }

    .link-label {
      font-size: 8px;
      fill: #aaa;
      pointer-events: none;
    }

    .node circle.highlight-main {
      stroke: #ffdd57;
      stroke-width: 3px;
    }

    .node circle.highlight-neighbor {
      stroke: #5ccfe6;
      stroke-width: 2px;
    }

    #hint {
      font-size: 12px;
      color: #aaa;
      margin-top: 10px;
    }

    #paths-to-ending {
      margin-top: 12px;
      font-size: 13px;
    }
    #paths-to-ending ul {
      padding-left: 16px;
      margin: 4px 0;
    }
    #paths-to-ending li {
      margin: 2px 0;
    }
  </style>
</head>
<body>

<div id="container">
  <div id="graph"></div>
  <div id="sidebar">
    <h1>Andi – Planned Story Graph</h1>
    <p style="color: #888; font-size: 12px;">Full planned story structure</p>

    <h2>Node details</h2>
    <p id="node-title"><em>Click a node in the graph.</em></p>
    <p id="node-type"></p>
    <p id="node-desc"></p>
    <h2>Outgoing edges</h2>
    <div id="node-edges"></div>

    <div id="paths-to-ending"></div>

    <div class="legend">
      <h2>Legend</h2>
      <div class="legend-item"><div class="legend-color" style="background: #4c6ef5;"></div> Intro</div>
      <div class="legend-item"><div class="legend-color" style="background: #37b24d;"></div> Hub</div>
      <div class="legend-item"><div class="legend-color" style="background: #f59f00;"></div> Branch</div>
      <div class="legend-item"><div class="legend-color" style="background: #e64980;"></div> Good Ending</div>
      <div class="legend-item"><div class="legend-color" style="background: #fa5252;"></div> Bad Ending</div>
      <div class="legend-item"><div class="legend-color" style="background: #444;"></div> Quick Bad End</div>
    </div>

    <div id="hint">Drag nodes, scroll to zoom. Click background to reset.</div>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  // ------------------------------
  // Node + Link Data (Planned Story - Based on Current + Extensions)
  // ------------------------------
  const nodes = [
    // === ACT 1: The Escape Begins ===
    { id: "start", type: "intro", desc: "Opening scene. Your last day at Rennweg. Badge disabled, desk empty." },

    // First branch - 3 paths from hallway
    { id: "main_stairs", type: "branch", desc: "Agnes from HR blocks your path with a mysterious document." },
    { id: "back_stairs", type: "branch", desc: "Joni and Norbert desperately need help with PhD code." },
    { id: "coffee_kitchen", type: "branch", desc: "One last sentimental coffee... but it's drugged!" },

    // Main stairs sub-branches
    { id: "document_signed", type: "branch", desc: "You sign without reading. What did you agree to?" },
    { id: "document_refusal", type: "branch", desc: "You refuse. Agnes triggers TERMINATION PROTOCOL." },
    { id: "attempt_pass", type: "branch", desc: "Try to run past Agnes. Roll d20 (need ≤13)." },
    { id: "d20_success", type: "branch", desc: "You leap over Agnes's trip attempt!" },
    { id: "d20_failure", type: "branch", desc: "Agnes trips you. Everything goes dark..." },

    // Back stairs sub-branches
    { id: "colleague_plea", type: "branch", desc: "Norbert grabs your sleeve, begging desperately." },
    { id: "corridor_safe", type: "branch", desc: "You ignore them and head to the back stairwell." },
    { id: "corridor_delayed", type: "branch", desc: "Fabio and Ali intercept you. 4th floor guilt trip." },
    { id: "fourth_floor", type: "branch", desc: "2 hours of whiteboard torture with Michi, Gilles, Ruling." },

    // === ACT 2: Midgame Complications (NEW) ===
    { id: "lobby_checkpoint", type: "hub", desc: "You reach the lobby. But security has questions..." },

    { id: "security_bribe", type: "branch", desc: "Offer the guard your leftover lunch money." },
    { id: "security_sneak", type: "branch", desc: "Wait for distraction and slip past." },
    { id: "security_confront", type: "branch", desc: "Boldly claim you have clearance." },

    { id: "parking_garage", type: "branch", desc: "Alternative exit through the basement garage." },
    { id: "fire_escape", type: "branch", desc: "Emergency stairs. Alarm might trigger..." },

    // === ACT 3: Final Escape ===
    { id: "exit_lobby", type: "hub", desc: "The front doors are in sight. Freedom awaits." },

    // === ENDINGS ===
    // Quick Bad Endings
    { id: "lost_to_coffee", type: "quickbad", desc: "BAD END: Drugged, chained to desk forever." },
    { id: "lost_to_HR", type: "quickbad", desc: "BAD END: Memory erased, stuck in yesterday's loop." },
    { id: "lost_to_PhD", type: "quickbad", desc: "BAD END: Absorbed by code until 2035." },
    { id: "lost_to_security", type: "quickbad", desc: "BAD END: Detained for 'suspicious behavior'." },
    { id: "lost_to_alarm", type: "quickbad", desc: "BAD END: Fire alarm lockdown. Re-employed." },

    // Standard Endings
    { id: "neutral_escape", type: "ending", desc: "NEUTRAL: You escape, but signed away your pension." },
    { id: "clean_escape", type: "ending", desc: "GOOD: Clean getaway. No strings attached." },

    // Special Endings (require multiple flags)
    { id: "revenge_ending", type: "ending", desc: "GOOD+: Expose HR's illegal contracts to the press. Requires: refused_document + found_evidence" },
    { id: "hero_ending", type: "ending", desc: "BEST: Save colleagues AND escape. Requires: helped_secretly + clean_escape" },
    { id: "coffee_ascension", type: "ending", desc: "SECRET: Transcend via coffee mastery. Requires: resisted_coffee + coffee_beans + perfect_brew" },
    { id: "true_ending", type: "ending", desc: "TRUE: The perfect run. Requires: all_colleagues_helped + hr_defeated + no_documents_signed + secret_found" }
  ];

  const links = [
    // === ACT 1 ===
    { source: "start", target: "main_stairs", label: "main_stairs" },
    { source: "start", target: "back_stairs", label: "back_stairs" },
    { source: "start", target: "coffee_kitchen", label: "get_coffee" },

    // Coffee path (instant trap)
    { source: "coffee_kitchen", target: "lost_to_coffee", label: "drink" },
    { source: "coffee_kitchen", target: "corridor_safe", label: "resist +coffee_resisted" },

    // Main stairs - HR encounter
    { source: "main_stairs", target: "document_signed", label: "sign" },
    { source: "main_stairs", target: "document_refusal", label: "refuse +refused_doc" },
    { source: "main_stairs", target: "attempt_pass", label: "run_past" },

    { source: "document_signed", target: "lobby_checkpoint", label: "signed_away" },
    { source: "document_refusal", target: "lost_to_HR", label: "protocol_alpha" },
    { source: "document_refusal", target: "parking_garage", label: "escape_chaos +found_evidence" },

    { source: "attempt_pass", target: "d20_success", label: "roll≤13" },
    { source: "attempt_pass", target: "d20_failure", label: "roll>13" },
    { source: "d20_success", target: "lobby_checkpoint", label: "+dodged_hr" },
    { source: "d20_failure", target: "lost_to_coffee", label: "captured" },

    // Back stairs - PhD trap
    { source: "back_stairs", target: "lost_to_PhD", label: "help_them" },
    { source: "back_stairs", target: "colleague_plea", label: "polite_no" },
    { source: "back_stairs", target: "corridor_safe", label: "fuck_off +rude" },

    { source: "colleague_plea", target: "lost_to_PhD", label: "fine_5min" },
    { source: "colleague_plea", target: "corridor_delayed", label: "refuse_again" },
    { source: "colleague_plea", target: "corridor_safe", label: "secret_help +helped_secretly" },

    { source: "corridor_safe", target: "lobby_checkpoint", label: "" },
    { source: "corridor_delayed", target: "fourth_floor", label: "go_4th" },
    { source: "corridor_delayed", target: "corridor_safe", label: "no_time" },
    { source: "fourth_floor", target: "lobby_checkpoint", label: "+whiteboard_survivor" },

    // === ACT 2: Lobby complications ===
    { source: "lobby_checkpoint", target: "security_bribe", label: "bribe" },
    { source: "lobby_checkpoint", target: "security_sneak", label: "sneak" },
    { source: "lobby_checkpoint", target: "security_confront", label: "confront" },
    { source: "lobby_checkpoint", target: "exit_lobby", label: "has:dodged_hr" },

    { source: "security_bribe", target: "exit_lobby", label: "+bribed_guard" },
    { source: "security_bribe", target: "lost_to_security", label: "insulted" },

    { source: "security_sneak", target: "exit_lobby", label: "+stealth" },
    { source: "security_sneak", target: "fire_escape", label: "spotted" },

    { source: "security_confront", target: "exit_lobby", label: "+intimidation" },
    { source: "security_confront", target: "lost_to_security", label: "failed_bluff" },

    { source: "parking_garage", target: "exit_lobby", label: "+garage_route" },
    { source: "parking_garage", target: "lost_to_security", label: "no_car_keys" },

    { source: "fire_escape", target: "exit_lobby", label: "lucky" },
    { source: "fire_escape", target: "lost_to_alarm", label: "alarm_triggered" },

    // === ACT 3: Endings ===
    { source: "exit_lobby", target: "neutral_escape", label: "has:signed_away" },
    { source: "exit_lobby", target: "clean_escape", label: "default" },
    { source: "exit_lobby", target: "revenge_ending", label: "has:refused_doc+found_evidence" },
    { source: "exit_lobby", target: "hero_ending", label: "has:helped_secretly+stealth" },
    { source: "exit_lobby", target: "coffee_ascension", label: "has:coffee_resisted+3_beans" },
    { source: "exit_lobby", target: "true_ending", label: "has:ALL_FLAGS" }
  ];

  // ------------------------------
  // Colors
  // ------------------------------
  const typeColor = {
    intro:    "#4c6ef5",
    hub:      "#37b24d",
    branch:   "#f59f00",
    ending:   "#e64980",
    bad:      "#fa5252",
    quickbad: "#444"
  };

  // ------------------------------
  // SVG + Zoom Layer
  // ------------------------------
  const width = document.getElementById("graph").clientWidth;
  const height = document.getElementById("graph").clientHeight;

  const svg = d3.select("#graph").append("svg")
    .attr("width", width)
    .attr("height", height);

  const zoomLayer = svg.append("g");

  svg.call(
    d3.zoom().scaleExtent([0.3, 3])
      .on("zoom", (event) => zoomLayer.attr("transform", event.transform))
  ).on("dblclick.zoom", null);

  // ------------------------------
  // Arrowhead marker (middle of edge)
  // ------------------------------
  const defs = svg.append("defs");

  // ------------------------------
  // Edges (straight lines with arrow in middle)
  // ------------------------------
  const link = zoomLayer.selectAll(".link")
    .data(links)
    .enter()
    .append("line")
    .attr("class", "link");

  // Arrow markers in middle of each edge
  const linkArrows = zoomLayer.selectAll(".link-arrow")
    .data(links)
    .enter()
    .append("path")
    .attr("class", "link-arrow")
    .attr("d", "M0,-5L10,0L0,5")
    .attr("fill", "#666");

  // Edge labels (flags)
  const linkLabels = zoomLayer.selectAll(".link-label")
    .data(links.filter(l => l.label))
    .enter()
    .append("text")
    .attr("class", "link-label")
    .text(d => d.label);

  // ------------------------------
  // Nodes
  // ------------------------------
  const node = zoomLayer.selectAll(".node")
    .data(nodes)
    .enter()
    .append("g")
    .attr("class", "node")
    .call(
      d3.drag()
        .on("start", dragStart)
        .on("drag", dragged)
        .on("end", dragEnd)
    );

  node.append("circle")
    .attr("r", d => d.type === "hub" ? 50 : 42)
    .attr("fill", d => typeColor[d.type]);

  node.append("text")
    .attr("text-anchor", "middle")
    .attr("dy", "0.35em")
    .each(function(d) {
      const text = d3.select(this);
      const lines = d.id.split("\n");
      if (lines.length > 1) {
        lines.forEach((line, i) => {
          text.append("tspan")
            .attr("x", 0)
            .attr("dy", i === 0 ? `-${(lines.length - 1) * 0.5}em` : "1em")
            .text(line);
        });
      } else {
        text.text(d.id);
      }
    });

  // ------------------------------
  // Force Layout
  // ------------------------------
  const sim = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(220))
    .force("charge", d3.forceManyBody().strength(-900))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("collision", d3.forceCollide().radius(75));

  sim.on("tick", () => {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    // Position arrows in middle of edge, rotated to point in direction of travel
    linkArrows.attr("transform", d => {
      const midX = (d.source.x + d.target.x) / 2;
      const midY = (d.source.y + d.target.y) / 2;
      const angle = Math.atan2(d.target.y - d.source.y, d.target.x - d.source.x) * 180 / Math.PI;
      return `translate(${midX}, ${midY}) rotate(${angle})`;
    });

    linkLabels
      .attr("x", d => (d.source.x + d.target.x) / 2)
      .attr("y", d => (d.source.y + d.target.y) / 2 - 10);

    node.attr("transform", d => `translate(${d.x}, ${d.y})`);
  });

  function dragStart(event, d) {
    if (!event.active) sim.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }
  function dragEnd(event, d) {
    if (!event.active) sim.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  // ------------------------------
  // Path finding to endings
  // ------------------------------
  function findPathsToNode(targetId) {
    const paths = [];

    function dfs(nodeId, currentPath, currentFlags) {
      if (nodeId === targetId) {
        paths.push({ path: [...currentPath], flags: [...currentFlags] });
        return;
      }

      const outgoing = links.filter(l => (l.source.id || l.source) === nodeId);
      for (const edge of outgoing) {
        const nextId = edge.target.id || edge.target;
        if (!currentPath.includes(nextId)) {
          currentPath.push(nextId);
          if (edge.label) currentFlags.push(edge.label);
          dfs(nextId, currentPath, currentFlags);
          currentPath.pop();
          if (edge.label) currentFlags.pop();
        }
      }
    }

    dfs("start", ["start"], []);
    return paths;
  }

  // ------------------------------
  // Sidebar logic
  // ------------------------------
  const titleEl = document.getElementById("node-title");
  const typeEl  = document.getElementById("node-type");
  const descEl  = document.getElementById("node-desc");
  const edgesEl = document.getElementById("node-edges");
  const pathsEl = document.getElementById("paths-to-ending");

  function clearHighlight() {
    link.classed("highlight", false);
    linkArrows.attr("fill", "#666");
    node.selectAll("circle")
      .classed("highlight-main", false)
      .classed("highlight-neighbor", false);
  }

  function showInfo(d) {
    titleEl.textContent = d.id.replace(/\n/g, " ");
    typeEl.textContent  = "Type: " + d.type;
    descEl.textContent  = d.desc;

    const outgoing = links.filter(l => (l.source.id || l.source) === d.id);
    if (outgoing.length) {
      edgesEl.innerHTML = "<ul>" + outgoing.map(l => {
        const targetId = (l.target.id || l.target).replace(/\n/g, " ");
        const label = l.label ? ` <em>[${l.label}]</em>` : "";
        return `<li><code>${targetId}</code>${label}</li>`;
      }).join("") + "</ul>";
    } else {
      edgesEl.innerHTML = "<em>No outgoing edges (ending).</em>";
    }

    // Show paths to this node if it's an ending
    if (d.type === "ending" || d.type === "bad" || d.type === "quickbad") {
      const paths = findPathsToNode(d.id);
      if (paths.length > 0) {
        let html = `<h2>How to reach this ending</h2><ul>`;
        for (const p of paths) {
          const flagStr = p.flags.length > 0 ? p.flags.join(" → ") : "(direct)";
          html += `<li>${flagStr}</li>`;
        }
        html += "</ul>";
        pathsEl.innerHTML = html;
      }
    } else {
      pathsEl.innerHTML = "";
    }
  }

  node.on("click", (e, d) => {
    e.stopPropagation();
    clearHighlight();

    d3.select(e.currentTarget).select("circle")
      .classed("highlight-main", true);

    links.forEach(l => {
      const s = l.source.id || l.source;
      const t = l.target.id || l.target;

      if (s === d.id || t === d.id) {
        link.filter(x => x === l).classed("highlight", true);
        linkArrows.filter(x => x === l).attr("fill", "#ffdd57");

        const neighbor = (s === d.id) ? t : s;
        node.filter(n => n.id === neighbor)
            .select("circle")
            .classed("highlight-neighbor", true);
      }
    });

    showInfo(d);
  });

  svg.on("click", () => {
    clearHighlight();
    titleEl.innerHTML = "<em>Click a node in the graph.</em>";
    typeEl.textContent = "";
    descEl.textContent = "";
    edgesEl.innerHTML = "";
    pathsEl.innerHTML = "";
  });
</script>

</body>
</html>
