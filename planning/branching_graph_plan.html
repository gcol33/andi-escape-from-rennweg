<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Andi – Planned Story Graph</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: system-ui, sans-serif;
      background: #111;
      color: #eee;
      overflow: hidden;
    }

    #container {
      display: grid;
      grid-template-columns: 3fr 1fr;
      height: 100%;
    }

    #graph {
      background: #151515;
    }

    #sidebar {
      border-left: 1px solid #333;
      padding: 12px;
      box-sizing: border-box;
      background: #181818;
      overflow-y: auto;
    }

    #sidebar h1 { font-size: 18px; margin-top: 0; }
    #sidebar h2 { font-size: 16px; margin: 10px 0 4px; }

    #sidebar p { font-size: 14px; margin: 4px 0; }
    #sidebar code { background: #222; padding: 2px 4px; border-radius: 3px; }

    .legend { margin-top: 16px; }
    .legend-item { display: flex; align-items: center; margin: 4px 0; font-size: 13px; }
    .legend-color { width: 16px; height: 16px; border-radius: 50%; margin-right: 8px; }

    .node circle {
      stroke: #111;
      stroke-width: 1.5px;
      cursor: pointer;
    }

    .node text {
      pointer-events: none;
      font-size: 10px;
      fill: #f5f5f5;
      text-shadow: 0 0 3px #000;
    }

    .link {
      fill: none;
      stroke: #666;
      stroke-width: 1.4px;
    }

    .link.highlight {
      stroke: #ffdd57;
      stroke-width: 2.4px;
    }

    .link-label {
      font-size: 8px;
      fill: #aaa;
      pointer-events: none;
    }

    .node circle.highlight-main {
      stroke: #ffdd57;
      stroke-width: 3px;
    }

    .node circle.highlight-neighbor {
      stroke: #5ccfe6;
      stroke-width: 2px;
    }

    #hint {
      font-size: 12px;
      color: #aaa;
      margin-top: 10px;
    }

    #paths-to-ending {
      margin-top: 12px;
      font-size: 13px;
    }
    #paths-to-ending ul {
      padding-left: 16px;
      margin: 4px 0;
    }
    #paths-to-ending li {
      margin: 2px 0;
    }
  </style>
</head>
<body>

<div id="container">
  <div id="graph"></div>
  <div id="sidebar">
    <h1>Andi – Planned Story Graph</h1>
    <p style="color: #888; font-size: 12px;">Full planned story structure</p>

    <h2>Node details</h2>
    <p id="node-title"><em>Click a node in the graph.</em></p>
    <p id="node-type"></p>
    <p id="node-desc"></p>
    <h2>Outgoing edges</h2>
    <div id="node-edges"></div>

    <div id="paths-to-ending"></div>

    <div class="legend">
      <h2>Legend</h2>
      <div class="legend-item"><div class="legend-color" style="background: #4c6ef5;"></div> Intro</div>
      <div class="legend-item"><div class="legend-color" style="background: #37b24d;"></div> Hub</div>
      <div class="legend-item"><div class="legend-color" style="background: #f59f00;"></div> Branch</div>
      <div class="legend-item"><div class="legend-color" style="background: #e64980;"></div> Good Ending</div>
      <div class="legend-item"><div class="legend-color" style="background: #fa5252;"></div> Bad Ending</div>
      <div class="legend-item"><div class="legend-color" style="background: #444;"></div> Quick Bad End</div>
    </div>

    <div id="hint">Drag nodes, scroll to zoom. Click background to reset.</div>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script>
  // ------------------------------
  // Node + Link Data (Planned Story - Based on Current + Extensions)
  // ------------------------------
  const nodes = [
    // === ACT 1: The Escape Begins ===
    { id: "start", type: "intro", desc: "Opening scene. Your last day at Rennweg. Badge disabled, desk empty." },

    // First branch - 3 paths from hallway
    { id: "main_stairs", type: "branch", desc: "Agnes from HR blocks your path with a mysterious document." },
    { id: "back_stairs", type: "branch", desc: "Joni and Norbert desperately need help with PhD code." },
    { id: "coffee_kitchen", type: "branch", desc: "One last sentimental coffee... but it's drugged!" },

    // === MAIN STAIRS PATH (HR Route) ===
    { id: "document_signed", type: "branch", desc: "You sign without reading. What did you agree to?" },
    { id: "document_refusal", type: "branch", desc: "You refuse. Agnes triggers TERMINATION PROTOCOL." },
    { id: "attempt_pass", type: "branch", desc: "Try to run past Agnes. Roll d20 (need ≤13)." },
    { id: "d20_success", type: "branch", desc: "You leap over Agnes's trip attempt!" },
    { id: "d20_failure", type: "branch", desc: "Agnes trips you. Everything goes dark..." },
    { id: "hr_chase", type: "branch", desc: "Agnes pursues you down the stairs!" },
    { id: "hr_showdown", type: "branch", desc: "Final confrontation with Agnes in the stairwell." },

    // === BACK STAIRS PATH (Colleague Route) ===
    { id: "colleague_plea", type: "branch", desc: "Norbert grabs your sleeve, begging desperately." },
    { id: "corridor_safe", type: "branch", desc: "You head to the back stairwell in peace." },
    { id: "corridor_delayed", type: "branch", desc: "Fabio and Ali intercept you. 4th floor guilt trip." },
    { id: "fourth_floor", type: "branch", desc: "2 hours of whiteboard torture with Michi, Gilles, Ruling." },
    { id: "secret_lab", type: "branch", desc: "You discover a hidden server room on the 4th floor." },
    { id: "basement_route", type: "branch", desc: "Take the service elevator to the basement." },

    // === COFFEE PATH (Secret Route) ===
    { id: "coffee_resist", type: "branch", desc: "You resist the drowsiness. Something's wrong here..." },
    { id: "coffee_investigate", type: "branch", desc: "Search the kitchen for clues about the drugged coffee." },
    { id: "coffee_master", type: "branch", desc: "You find the sacred beans and brew the perfect cup." },

    // === CONVERGENCE POINTS (not all-in-one) ===
    { id: "ground_floor", type: "hub", desc: "Ground floor. Multiple exits visible." },
    { id: "parking_garage", type: "branch", desc: "The dark parking garage. Your car is somewhere..." },
    { id: "fire_exit", type: "branch", desc: "Emergency exit. Alarm will sound." },
    { id: "front_door", type: "branch", desc: "Main entrance. Security guard Hans is watching." },
    { id: "loading_dock", type: "branch", desc: "Back loading area. Delivery truck leaving soon." },

    // === BAD ENDINGS (scattered throughout) ===
    { id: "lost_to_coffee", type: "quickbad", desc: "BAD: Drugged, chained to desk forever." },
    { id: "lost_to_HR", type: "quickbad", desc: "BAD: Memory erased, stuck in yesterday's loop." },
    { id: "lost_to_PhD", type: "quickbad", desc: "BAD: Absorbed by code until 2035." },
    { id: "lost_to_security", type: "quickbad", desc: "BAD: Detained for 'suspicious behavior'." },
    { id: "lost_to_alarm", type: "quickbad", desc: "BAD: Fire alarm lockdown. Re-employed." },
    { id: "lost_to_agnes", type: "quickbad", desc: "BAD: Agnes catches you. Eternal contract." },

    // === GOOD ENDINGS (from different paths) ===
    { id: "pension_escape", type: "ending", desc: "NEUTRAL: Escape but signed away pension." },
    { id: "clean_escape", type: "ending", desc: "GOOD: Clean getaway via front door." },
    { id: "garage_escape", type: "ending", desc: "GOOD: Drive off into the sunset." },
    { id: "truck_escape", type: "ending", desc: "GOOD: Hitch a ride on delivery truck." },

    // === SPECIAL ENDINGS (unique paths) ===
    { id: "revenge_ending", type: "ending", desc: "REVENGE: Expose HR corruption to press. +refused_doc +evidence" },
    { id: "hero_ending", type: "ending", desc: "HERO: Secretly helped colleagues AND escaped clean." },
    { id: "coffee_ascension", type: "ending", desc: "SECRET: Transcend via perfect coffee brew." },
    { id: "true_ending", type: "ending", desc: "TRUE: Defeated Agnes, helped everyone, found all secrets." }
  ];

  const links = [
    // === FROM START ===
    { source: "start", target: "main_stairs", label: "main_stairs" },
    { source: "start", target: "back_stairs", label: "back_stairs" },
    { source: "start", target: "coffee_kitchen", label: "get_coffee" },

    // === COFFEE PATH ===
    { source: "coffee_kitchen", target: "lost_to_coffee", label: "drink" },
    { source: "coffee_kitchen", target: "coffee_resist", label: "resist" },
    { source: "coffee_resist", target: "coffee_investigate", label: "investigate" },
    { source: "coffee_resist", target: "corridor_safe", label: "leave" },
    { source: "coffee_investigate", target: "coffee_master", label: "brew_perfect" },
    { source: "coffee_investigate", target: "back_stairs", label: "give_up" },
    { source: "coffee_master", target: "coffee_ascension", label: "transcend" },

    // === MAIN STAIRS - HR PATH ===
    { source: "main_stairs", target: "document_signed", label: "sign" },
    { source: "main_stairs", target: "document_refusal", label: "refuse" },
    { source: "main_stairs", target: "attempt_pass", label: "run_past" },

    { source: "document_signed", target: "ground_floor", label: "+signed_pension" },
    { source: "document_refusal", target: "lost_to_HR", label: "submit" },
    { source: "document_refusal", target: "hr_chase", label: "run +evidence" },

    { source: "attempt_pass", target: "d20_success", label: "roll≤13" },
    { source: "attempt_pass", target: "d20_failure", label: "roll>13" },
    { source: "d20_success", target: "ground_floor", label: "+dodged_hr" },
    { source: "d20_failure", target: "lost_to_coffee", label: "captured" },

    { source: "hr_chase", target: "hr_showdown", label: "cornered" },
    { source: "hr_chase", target: "parking_garage", label: "lose_her" },
    { source: "hr_showdown", target: "lost_to_agnes", label: "submit" },
    { source: "hr_showdown", target: "revenge_ending", label: "defeat +evidence" },

    // === BACK STAIRS - COLLEAGUE PATH ===
    { source: "back_stairs", target: "lost_to_PhD", label: "help_fully" },
    { source: "back_stairs", target: "colleague_plea", label: "polite_no" },
    { source: "back_stairs", target: "corridor_safe", label: "ignore" },

    { source: "colleague_plea", target: "lost_to_PhD", label: "fine_5min" },
    { source: "colleague_plea", target: "corridor_delayed", label: "refuse_again" },
    { source: "colleague_plea", target: "hero_ending", label: "secret_help +helped" },

    { source: "corridor_safe", target: "ground_floor", label: "downstairs" },
    { source: "corridor_safe", target: "basement_route", label: "service_elevator" },

    { source: "corridor_delayed", target: "fourth_floor", label: "go_4th" },
    { source: "corridor_delayed", target: "corridor_safe", label: "no_time" },

    { source: "fourth_floor", target: "ground_floor", label: "escape_whiteboard" },
    { source: "fourth_floor", target: "secret_lab", label: "find_secret" },
    { source: "secret_lab", target: "true_ending", label: "+all_secrets" },
    { source: "secret_lab", target: "basement_route", label: "use_elevator" },

    { source: "basement_route", target: "parking_garage", label: "to_garage" },
    { source: "basement_route", target: "loading_dock", label: "to_dock" },

    // === GROUND FLOOR BRANCHES ===
    { source: "ground_floor", target: "front_door", label: "front" },
    { source: "ground_floor", target: "fire_exit", label: "emergency" },
    { source: "ground_floor", target: "parking_garage", label: "garage" },

    // === EXIT PATHS ===
    { source: "front_door", target: "clean_escape", label: "walk_past" },
    { source: "front_door", target: "lost_to_security", label: "caught" },
    { source: "front_door", target: "pension_escape", label: "has:signed" },

    { source: "fire_exit", target: "clean_escape", label: "lucky" },
    { source: "fire_exit", target: "lost_to_alarm", label: "alarm" },

    { source: "parking_garage", target: "garage_escape", label: "find_car" },
    { source: "parking_garage", target: "lost_to_security", label: "no_keys" },

    { source: "loading_dock", target: "truck_escape", label: "hitch_ride" },
    { source: "loading_dock", target: "lost_to_security", label: "spotted" }
  ];

  // ------------------------------
  // Colors
  // ------------------------------
  const typeColor = {
    intro:    "#4c6ef5",
    hub:      "#37b24d",
    branch:   "#f59f00",
    ending:   "#e64980",
    bad:      "#fa5252",
    quickbad: "#444"
  };

  // ------------------------------
  // SVG + Zoom Layer
  // ------------------------------
  const width = document.getElementById("graph").clientWidth;
  const height = document.getElementById("graph").clientHeight;

  const svg = d3.select("#graph").append("svg")
    .attr("width", width)
    .attr("height", height);

  const zoomLayer = svg.append("g");

  svg.call(
    d3.zoom().scaleExtent([0.3, 3])
      .on("zoom", (event) => zoomLayer.attr("transform", event.transform))
  ).on("dblclick.zoom", null);

  // ------------------------------
  // Arrowhead marker (middle of edge)
  // ------------------------------
  const defs = svg.append("defs");

  // ------------------------------
  // Edges (straight lines with arrow in middle)
  // ------------------------------
  const link = zoomLayer.selectAll(".link")
    .data(links)
    .enter()
    .append("line")
    .attr("class", "link");

  // Arrow markers in middle of each edge
  const linkArrows = zoomLayer.selectAll(".link-arrow")
    .data(links)
    .enter()
    .append("path")
    .attr("class", "link-arrow")
    .attr("d", "M0,-5L10,0L0,5")
    .attr("fill", "#666");

  // Edge labels (flags)
  const linkLabels = zoomLayer.selectAll(".link-label")
    .data(links.filter(l => l.label))
    .enter()
    .append("text")
    .attr("class", "link-label")
    .text(d => d.label);

  // ------------------------------
  // Nodes
  // ------------------------------
  const node = zoomLayer.selectAll(".node")
    .data(nodes)
    .enter()
    .append("g")
    .attr("class", "node")
    .call(
      d3.drag()
        .on("start", dragStart)
        .on("drag", dragged)
        .on("end", dragEnd)
    );

  node.append("circle")
    .attr("r", d => d.type === "hub" ? 50 : 42)
    .attr("fill", d => typeColor[d.type]);

  node.append("text")
    .attr("text-anchor", "middle")
    .attr("dy", "0.35em")
    .each(function(d) {
      const text = d3.select(this);
      const lines = d.id.split("\n");
      if (lines.length > 1) {
        lines.forEach((line, i) => {
          text.append("tspan")
            .attr("x", 0)
            .attr("dy", i === 0 ? `-${(lines.length - 1) * 0.5}em` : "1em")
            .text(line);
        });
      } else {
        text.text(d.id);
      }
    });

  // ------------------------------
  // Force Layout
  // ------------------------------
  const sim = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(links).id(d => d.id).distance(220))
    .force("charge", d3.forceManyBody().strength(-900))
    .force("center", d3.forceCenter(width / 2, height / 2))
    .force("collision", d3.forceCollide().radius(75));

  sim.on("tick", () => {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);

    // Position arrows in middle of edge, rotated to point in direction of travel
    linkArrows.attr("transform", d => {
      const midX = (d.source.x + d.target.x) / 2;
      const midY = (d.source.y + d.target.y) / 2;
      const angle = Math.atan2(d.target.y - d.source.y, d.target.x - d.source.x) * 180 / Math.PI;
      return `translate(${midX}, ${midY}) rotate(${angle})`;
    });

    linkLabels
      .attr("x", d => (d.source.x + d.target.x) / 2)
      .attr("y", d => (d.source.y + d.target.y) / 2 - 10);

    node.attr("transform", d => `translate(${d.x}, ${d.y})`);
  });

  function dragStart(event, d) {
    if (!event.active) sim.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
  }
  function dragEnd(event, d) {
    if (!event.active) sim.alphaTarget(0);
    d.fx = null;
    d.fy = null;
  }

  // ------------------------------
  // Path finding to endings
  // ------------------------------
  function findPathsToNode(targetId) {
    const paths = [];

    function dfs(nodeId, currentPath, currentFlags) {
      if (nodeId === targetId) {
        paths.push({ path: [...currentPath], flags: [...currentFlags] });
        return;
      }

      const outgoing = links.filter(l => (l.source.id || l.source) === nodeId);
      for (const edge of outgoing) {
        const nextId = edge.target.id || edge.target;
        if (!currentPath.includes(nextId)) {
          currentPath.push(nextId);
          if (edge.label) currentFlags.push(edge.label);
          dfs(nextId, currentPath, currentFlags);
          currentPath.pop();
          if (edge.label) currentFlags.pop();
        }
      }
    }

    dfs("start", ["start"], []);
    return paths;
  }

  // ------------------------------
  // Sidebar logic
  // ------------------------------
  const titleEl = document.getElementById("node-title");
  const typeEl  = document.getElementById("node-type");
  const descEl  = document.getElementById("node-desc");
  const edgesEl = document.getElementById("node-edges");
  const pathsEl = document.getElementById("paths-to-ending");

  function clearHighlight() {
    link.classed("highlight", false);
    linkArrows.attr("fill", "#666");
    node.selectAll("circle")
      .classed("highlight-main", false)
      .classed("highlight-neighbor", false);
  }

  function showInfo(d) {
    titleEl.textContent = d.id.replace(/\n/g, " ");
    typeEl.textContent  = "Type: " + d.type;
    descEl.textContent  = d.desc;

    const outgoing = links.filter(l => (l.source.id || l.source) === d.id);
    if (outgoing.length) {
      edgesEl.innerHTML = "<ul>" + outgoing.map(l => {
        const targetId = (l.target.id || l.target).replace(/\n/g, " ");
        const label = l.label ? ` <em>[${l.label}]</em>` : "";
        return `<li><code>${targetId}</code>${label}</li>`;
      }).join("") + "</ul>";
    } else {
      edgesEl.innerHTML = "<em>No outgoing edges (ending).</em>";
    }

    // Show paths to this node if it's an ending
    if (d.type === "ending" || d.type === "bad" || d.type === "quickbad") {
      const paths = findPathsToNode(d.id);
      if (paths.length > 0) {
        let html = `<h2>How to reach this ending</h2><ul>`;
        for (const p of paths) {
          const flagStr = p.flags.length > 0 ? p.flags.join(" → ") : "(direct)";
          html += `<li>${flagStr}</li>`;
        }
        html += "</ul>";
        pathsEl.innerHTML = html;
      }
    } else {
      pathsEl.innerHTML = "";
    }
  }

  node.on("click", (e, d) => {
    e.stopPropagation();
    clearHighlight();

    d3.select(e.currentTarget).select("circle")
      .classed("highlight-main", true);

    links.forEach(l => {
      const s = l.source.id || l.source;
      const t = l.target.id || l.target;

      if (s === d.id || t === d.id) {
        link.filter(x => x === l).classed("highlight", true);
        linkArrows.filter(x => x === l).attr("fill", "#ffdd57");

        const neighbor = (s === d.id) ? t : s;
        node.filter(n => n.id === neighbor)
            .select("circle")
            .classed("highlight-neighbor", true);
      }
    });

    showInfo(d);
  });

  svg.on("click", () => {
    clearHighlight();
    titleEl.innerHTML = "<em>Click a node in the graph.</em>";
    typeEl.textContent = "";
    descEl.textContent = "";
    edgesEl.innerHTML = "";
    pathsEl.innerHTML = "";
  });
</script>

</body>
</html>
